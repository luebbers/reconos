##
## \file delegate.templ   cheetah template for ecos delegate thread
##
## ReconOS delegate thread code for eCos. You can generate the actual
## delegate.c code by issuing
##
##   cheetah compile delegate.tmpl -p | python | indent > delegate.c
##
## or (recommended) by invoking
##
##   make
##
## in this directory.
##
## \author     Enno Luebbers   <enno.luebbers@upb.de>
## \date       30.10.2008
##
##---------------------------------------------------------------------------
## %%%RECONOS_COPYRIGHT_BEGIN%%%
## 
## This file is part of ReconOS (http://www.reconos.de).
## Copyright (c) 2006-2010 The ReconOS Project and contributors (see AUTHORS).
## All rights reserved.
## 
## ReconOS is free software: you can redistribute it and/or modify it under
## the terms of the GNU General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
## 
## ReconOS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
## details.
## 
## You should have received a copy of the GNU General Public License along
## with ReconOS.  If not, see <http://www.gnu.org/licenses/>.
## 
## %%%RECONOS_COPYRIGHT_END%%%
##---------------------------------------------------------------------------
##
## Major Changes:
##
## 07.11.2008   Enno Luebbers   wrote generator delegate.tmpl for delegate.c
## 29.01.2009   Enno Luebbers   added support for partial reconfiguration
##
<%
import sys, os
import cmddef
import string
import pyparsing

# command definition files to consider for the eCos delegate thread code
files = sys.argv[1:]
#        ['cond_broadcast.cmddef',
#         'cond_signal.cmddef',
#         'cond_wait.cmddef',
#         'get_init_data.cmddef',
#         'mbox_get.cmddef',
#         'mbox_put.cmddef',
#         'mq_receive.cmddef',
#         'mq_send.cmddef',
#         'mutex_lock.cmddef',
#         'mutex_release.cmddef',
#         'mutex_trylock.cmddef',
#         'mutex_unlock.cmddef',
#         'sem_post.cmddef',
#         'sem_wait.cmddef',
#         'thread_exit.cmddef']

# substitutions for the CODE section of the command definiton
# (can also be used via $subst['xxx'] within this template)
subst = {
        'data'           : 'request.data',           # data passed from HW thread
        'datax'          : 'request.datax',          # extended data from HW thread
        'flags'          : 'request.command.flags',          # command flags
        'saved_state_enc': 'request.command.saved_state_enc',# saved state (encoded)
        'saved_step_enc' : 'request.command.saved_step_enc', # saved step
        'resources'      : 'hwt->resources',         # threads resource array
        'resource_count' : 'hwt->resource_count',    # number of resources
        'retval'         : 'retval',                 # return value variable
        'flags'          : 'hwt->flags',             # thread flags
        'plb_base_addr'  : 'hwt->slot->plb_base_addr'      # PLB base address FIXME:
                                                     #                  needed?
        }

# standard header files that are always needed
std_headers = [ ( '', '<reconos/reconos.h>' ),
                ( '', '<stdlib.h>' ),
                ( '', '<stdio.h>' ),
                ( '', '<cyg/kernel/kapi.h>' ),
                ( '', '<cyg/infra/diag.h>' ),
                ( '', '<reconos/osif_comm.h>' ) ]

# read all command files
potential_commands = cmddef.parse_files( files )

# find all commands and delegates relevant to ecos, and assemble headers
commands = []
delegates = []
all_headers = std_headers
for c in potential_commands:
    for d in c.delegates:
        if d.hostOs.lower() == 'ecos':
            if c not in commands:
                commands.append(c)
            if d not in delegates:
                delegates.append(d)
            for h in d.headers:
                all_headers.append((d.ifdef, h))        # allow only 1 ifdef

all_headers.sort()

# remove duplicate header files
assert len(all_headers) > 0
last = all_headers[0]
i = 1
lasti = 1
while i < len(all_headers):
    if all_headers[i] != last:
        all_headers[lasti] = last = all_headers[i]
        lasti += 1
    i += 1
headers = all_headers[:lasti]

%>
##
## =================== actual C code starts here ===========================
##
///
/// \file delegate.c
///
/// ReconOS delegate thread code for eCos. NOTE: This file is generated from
/// delegate.tmpl.
///
/// DO NOT EDIT THIS FILE - it will be regenerated, overwriting your changes
/// Edit the command definitions in \$RECONOS/defs or delegate.tmpl instead.
///
/// \author     Enno Luebbers   <enno.luebbers@upb.de>
/// \date       30.10.2008
//
//---------------------------------------------------------------------------
// %%%RECONOS_COPYRIGHT_BEGIN%%%
// 
// This file is part of ReconOS (http://www.reconos.de).
// Copyright (c) 2006-2010 The ReconOS Project and contributors (see AUTHORS).
// All rights reserved.
// 
// ReconOS is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// ReconOS is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along
// with ReconOS.  If not, see <http://www.gnu.org/licenses/>.
// 
// %%%RECONOS_COPYRIGHT_END%%%
//---------------------------------------------------------------------------
//
// Major Changes:
//
// 30.10.2008   Enno Luebbers   delegate thread code seperated from reconos.c
// 07.11.2008   Enno Luebbers   wrote generator delegate.tmpl for delegate.c
// 29.01.2009   Enno Luebbers   added support for partial reconfiguration
//

#set $lasti = None
#for $i, $h in $headers
    #if $i and $i != $lasti
        #if $lasti
\#endif
        #end if
\#ifdef $i
    #set $lasti = $i
    #end if
\#include $h
#end for
#if $lasti
\#endif
#end if

// CONSTANTS and MACROS ====================================================

\#ifdef UPBDBG_RECONOS_DEBUG
\#define DEBUG_PRINTF(format, args...) diag_printf(format , \#\#args)
\#else
\#define DEBUG_PRINTF(format, args...)
\#endif

// ReconOS command encoding constants
// task2os commands
#for $c in $commands
\#define $c.symbol      $c.encoding
#end for


// TYPE DEFINITIONS ========================================================


// FUNCTION PROTOTYPES =====================================================

// FIXME: should this be in a header file?
\#ifdef CYGPKG_KERNEL_THREADS_DESTRUCTORS
void reconos_delegate_thread_destructor(cyg_addrword_t data);   // defined in reconos.c
\#endif

extern reconos_slot_t reconos_slots[NUM_OSIFS];
\#ifdef UPBFUN_RECONOS_PARTIAL
cyg_mutex_t reconos_hwsched_mutex;
cyg_cond_t  reconos_hwsched_condvar;
cyg_sem_t   reconos_hwsched_semaphore;
\#endif


// FUNCTIONS ===============================================================


/**** DEPRECATED ****

///
/// Find a free slot
///
/// Returns an index into the possible_slots array, or -1
/// if none of the slots are free or ready.
///

int find_free_slot(uint8 *possible_slots, uint8 num_possible_slots) {
    int i, j;

    for (i = 0; i < num_possible_slots; i++) {
        // either free or not-executing slots are okay
        j = possible_slots[i];
        if (reconos_slots[j].state == FREE ||
            reconos_slots[j].state == READY) {
           return i;
        }
    }
    return -1;
}


///
/// Prepare thread for execution
///
/// Finds suitable slot and loads bitstreams, or waits until
/// a slot becomes free
///
void prep_exec(rthread_attr_t *hwt) {
\#ifdef UPBFUN_RECONOS_PARTIAL
    int i, j;
    uint8 possible_slots[NUM_OSIFS];
    reconos_bitstream_t *possible_bitstreams[NUM_OSIFS];
    uint8 num_possible_slots = 0;

    if (hwt->flags & RTHREAD_ATTR_IS_DYNAMIC) {
        // find possible slots and bitstreams
        for (i = 0; i < NUM_OSIFS; i++) {
            for (j = 0; j < hwt->circuit->num_bitstreams; j++) {
                if (hwt->circuit->bitstreams[j]->slot_num == i) {
                    possible_slots[num_possible_slots] = i;
                    possible_bitstreams[num_possible_slots++] = 
                        hwt->circuit->bitstreams[j];
                }
            }
        }
        if (hwt->circuit->num_bitstreams == 0) {
            diag_printf("no bitstreams available for circuit '%s'\n",
                        hwt->circuit->name);
            cyg_thread_exit();
        }

        // find first free slot FIXME: schedule this better?
        if (!cyg_mutex_lock(&reconos_slots_mutex)) {
            CYG_FAIL("mutex lock failed, aborting thread\n");
        } else {

            while(( i = find_free_slot(possible_slots, num_possible_slots)) < 0) { 
                cyg_cond_wait(&reconos_slots_wait);
            }

            j = possible_slots[i];
            reconos_slots[j].state = RUNNING;
            // now, j = possible_slots[i] is the slot to use
            hwt->slot = &reconos_slots[j];
            hwt->slot->thread = hwt;

            cyg_mutex_unlock(&reconos_slots_mutex);

        }

        // disable bus macros (just in case)
        osif_set_busmacro(hwt, OSIF_DATA_BUSMACRO_DISABLE);
        // load bitstream
        DEBUG_PRINTF("loading bitstream for circuit '%s' into slot %d...",
            hwt->circuit->name, j);
        icap_load(possible_bitstreams[i]->data, possible_bitstreams[i]->size);
        DEBUG_PRINTF("done\n");

    } else // static thread

\#endif // UPBFUN_RECONOS_PARTIAL
    {   
        if (!cyg_mutex_lock(&reconos_slots_mutex)) {
            CYG_FAIL("mutex lock failed, aborting thread\n");
        } else {
            CYG_ASSERT(hwt->slot, "no slot associated with static thread");
            while (hwt->slot->state != READY) {
                cyg_cond_wait(&reconos_slots_wait);
            }

            hwt->slot->state = RUNNING;
            hwt->slot->thread = hwt;
            cyg_mutex_unlock(&reconos_slots_mutex);
        }
    }
}            

**********************/

//-----------------------------------------
// eCos delegate thread
//-----------------------------------------
void reconos_delegate_thread(cyg_addrword_t data)
{
	rthread_attr_t *hwt = (rthread_attr_t*)data;
	osif_task2os_t request;
	uint32 retval;
    char self_name[100];

\#ifdef CYGPKG_KERNEL_THREADS_DESTRUCTORS
	cyg_bool_t result = cyg_thread_add_destructor(reconos_delegate_thread_destructor, (cyg_addrword_t)hwt);
	CYG_ASSERT (result, "Failed to attach delegate thread destructor!");
\#endif

\#ifdef UPBDBG_RECONOS_DEBUG
    cyg_thread_info self_info;
    strncpy( self_name, cyg_thread_get_info(cyg_thread_self(), cyg_thread_get_id(cyg_thread_self()), &self_info) ? self_info.name : "UNKNOWN", 20);

	rthread_attr_dump(hwt);
\#endif

        // prepare for execution
//        prep_exec(hwt);

\#ifdef UPBFUN_RECONOS_PARTIAL
        // lock scheduling mutex
        if (!cyg_mutex_lock(&reconos_hwsched_mutex)) {
            CYG_FAIL("scheduling mutex lock failed, aborting thread\n");
        };

        // load hardware, if we're not static
        if (hwt->flags & RTHREAD_ATTR_IS_DYNAMIC) {
            DEBUG_PRINTF("thread '%s': requesting bitstream load\n", self_name);
            // set RECONFIG flag
            hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
            // signal hw scheduler
            cyg_semaphore_post( &reconos_hwsched_semaphore ); 
            // now wait until our circuit has been configured to the system
            while (hwt->slot == NULL) {
                cyg_cond_wait( &reconos_hwsched_condvar );
            }
        }
        DEBUG_PRINTF("thread '%s': setting slot state to RUNNING\n", self_name);
        hwt->slot->state = RUNNING;
        cyg_mutex_unlock( &reconos_hwsched_mutex );
\#endif

        CYG_ASSERT( hwt->slot != NULL, "no slot to execute thread in" );
        CYG_ASSERT( hwt == hwt->slot->thread, "thread->slot->thread links corrupt" );

        // lock osif mutex
        if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
            CYG_FAIL("osif mutex lock failed, aborting thread\n");
        };

	// Reset HW thread
        DEBUG_PRINTF("thread '%s': ", self_name);
	osif_reset(hwt->slot);

	// wait a little FIXME: does this impede performance?
        cyg_mutex_unlock(&(hwt->slot->mutex));
	cyg_thread_delay(1);
        if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
            CYG_FAIL("osif mutex lock failed, aborting thread\n");
        };

	// pass initialization data to hardware thread
        DEBUG_PRINTF("thread '%s': ", self_name);
        osif_set_init_data(hwt->slot, hwt->init_data);

	// write local FIFO handles
        DEBUG_PRINTF("thread '%s': ", self_name);
        osif_set_fifo_handles(hwt->slot, hwt->fifo_read_index, hwt->fifo_write_index);

	// enable bus macros
        DEBUG_PRINTF("thread '%s': ", self_name);
        osif_set_busmacro(hwt->slot, 1);

	// unblock hardware
        DEBUG_PRINTF("thread '%s': ", self_name);
        osif_unblock(hwt->slot);

        cyg_mutex_unlock(&(hwt->slot->mutex));

	for (;;) {
		// wait for reconos delegate semaphore
		cyg_semaphore_wait(&(hwt->delegate_semaphore));

		// read command and data
                if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
                    CYG_FAIL("osif mutex lock failed, aborting thread\n");
                };
                DEBUG_PRINTF("thread '%s': ", self_name);
                osif_read_call_parameters( hwt->slot, &request );
                cyg_mutex_unlock(&(hwt->slot->mutex));

\#ifdef UPBFUN_RECONOS_PARTIAL
                if (request.command.flags & OSIF_FLAGS_YIELD)  {
                    // this is a yielding call!
                    DEBUG_PRINTF("thread '%s': yielding call!\n",self_name);
                    // lock scheduling mutex
                    if (!cyg_mutex_lock(&reconos_hwsched_mutex)) {
                        CYG_FAIL("scheduling mutex lock failed, aborting thread\n");
                    };
                    // save context (TODO: not yet implemented!)
                    if( hwt->state_size > 0) {
\#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
                        // invalidate cache lines corresponding to burst RAM
                        // FIXME: memory offset is hardcoded!
                        XCache_InvalidateDCacheRange((unsigned int)(hwt->slot->plb_base_addr + 0x4000), hwt->state_size);
\#endif
                        // FIXME: memory offset is hardcoded!
                        memcpy(hwt->state_buf, hwt->slot->plb_base_addr + 0x4000, hwt->state_size);
                    }
                    // save state
                    hwt->saved_command = request.command;       // this saves state and step
                    // hwt->saved_state_enc = request.command.saved_state_enc;
                    
                    // set YIELD flag
                    hwt->flags |= RTHREAD_ATTR_YIELDS;
                    // unlock scheduling mutex
                    cyg_mutex_unlock( &reconos_hwsched_mutex );
                    // signal scheduling thread
                    cyg_semaphore_post( &reconos_hwsched_semaphore ); 
                }
\#endif

		switch (request.command.code) {

#for $c in $commands
                    //---------------------------------------------
                    // $c.name
                    // generated from $c.filename
                    //---------------------------------------------
                case $c.symbol:
    #set $c_delegates = $filter( lambda x: x.command == c, $delegates )
    #set $d_restype = $filter( lambda x: x.restype, $c_delegates )
    #set $d_no_restype = $filter( lambda x: not x.restype, $c_delegates )

    ##..........................................................................
    ## insert all delegate code sections which are restype dependent
    ##
    #if $d_restype
        CYG_ASSERT( $subst['data'] < $subst['resource_count'], "$c.name operation requested on non-existing resource!" );
        switch ( $subst['resources'] [ $subst['data'] ].type ) {
        #for d in d_restype
            #if $d.ifdef
    \#ifdef $i
            #end if

            // $d.name ($d.restype) ------------------
            case $d.restype:
                {
                    $string.Template($d.code).substitute($subst)
                }
                break;

            #if $d.ifdef
    \#endif
            #end if
        #end for  ## d in d_restype
            default: 
                CYG_FAIL( "$c.name operation requested on invalid resource type!" );
            }
    #end if   ## d_restype

    ##..........................................................................
    ## insert all general code (not distinguished by restype) at the end
    ##
    #if $d_no_restype
        #for $d in $d_no_restype
            #if $d.ifdef
    \#ifdef $i
            #end if

                // $d.name ($d.restype) ------------------
                {
                    $string.Template($d.code).substitute($subst)
                }

            #if $d.ifdef
    \#endif
            #end if
        #end for  ## d in d_no_restype
    #end if   ## d_no_restype

    ##..........................................................................
    ## make sure our hardware is back before continuing

\#ifdef UPBFUN_RECONOS_PARTIAL
    if (request.command.flags & OSIF_FLAGS_YIELD)  {
        // this was a yielding call!
        // lock scheduling mutex
        if (!cyg_mutex_lock(&reconos_hwsched_mutex)) {
            CYG_FAIL("scheduling mutex lock failed, aborting thread\n");
        };
        // clear YIELD flag
        hwt->flags &= ~RTHREAD_ATTR_YIELDS;
        if (hwt->slot == NULL) {        // whoa! out hardware's not here
            DEBUG_PRINTF("thread '%s': requesting bitstream load\n", self_name);
            // set RECONFIG flag
            hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
            // signal hw scheduler
            cyg_semaphore_post( &reconos_hwsched_semaphore ); 
            // now wait until our circuit has been configured to the system
            while (hwt->slot == NULL) {
                cyg_cond_wait( &reconos_hwsched_condvar );
            }
            hwt->slot->state = RUNNING;
            // lock osif mutex
            if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
                CYG_FAIL("osif mutex lock failed, aborting thread\n");
            };
            // reset osif
            DEBUG_PRINTF("thread '%s': ", self_name);
            osif_reset( hwt->slot );
            // restore context (TODO: not yet implemented!)
            if( hwt->state_size > 0) {
                memcpy(hwt->slot->plb_base_addr + 0x4000, hwt->state_buf, hwt->state_size);
\#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
                // flush cache lines corresponding to burst RAM
                // FIXME: memory offset is hardcoded!
                XCache_FlushDCacheRange((unsigned int)(hwt->slot->plb_base_addr + 0x4000), hwt->state_size);
\#endif
            }
            // restore fsm state
            DEBUG_PRINTF("thread '%s': ", self_name);
            osif_set_resume( hwt->slot, hwt->saved_command );     // sets resume state and step according to saved command
            // pass initialization data to hardware thread
            DEBUG_PRINTF("thread '%s': ", self_name);
            osif_set_init_data(hwt->slot, hwt->init_data);
            // write local FIFO handles
            DEBUG_PRINTF("thread '%s': ", self_name);
            osif_set_fifo_handles(hwt->slot, hwt->fifo_read_index, hwt->fifo_write_index);
            // enable bus macros
            DEBUG_PRINTF("thread '%s': ", self_name);
            osif_set_busmacro(hwt->slot, 1);
            // unblock hardware
            DEBUG_PRINTF("thread '%s': ", self_name);
            osif_unblock(hwt->slot);
            // unlock osif mutex
            cyg_mutex_unlock( &(hwt->slot->mutex) );
        }
        // unlock scheduling mutex
        cyg_mutex_unlock( &reconos_hwsched_mutex );
    }
\#endif            

    ##..........................................................................
    ## insert write_result to HW thread, if necessary
    ##
    #if $c.options and 'RETVAL' in $c.options
        if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
            CYG_FAIL("osif mutex lock failed, aborting thread\n");
        };
        DEBUG_PRINTF("thread '%s': ", self_name);
        osif_write_result( hwt->slot, $subst['retval'] );
        cyg_mutex_unlock(&(hwt->slot->mutex));
    #elif $c.options and 'BLOCKING' in $c.options
        if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
            CYG_FAIL("osif mutex lock failed, aborting thread\n");
        };
        DEBUG_PRINTF("thread '%s': ", self_name);
        osif_unblock( hwt->slot );
        cyg_mutex_unlock(&(hwt->slot->mutex));
    #end if
        break;

#end for  ## commands

    default:
            CYG_FAIL("Delegate thread received unknown command from HW thread");
    }

    DEBUG_PRINTF("<< delegate processing done for task at DCR 0x%03X\n", hwt->slot->dcr_base_addr);

  }
}

